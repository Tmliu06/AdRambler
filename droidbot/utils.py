import re
import functools
import os
import time
from datetime import datetime

# logcat regex, which will match the log message generated by `adb logcat -v threadtime`
LOGCAT_THREADTIME_RE = re.compile('^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+'
                                  '(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$')


def lazy_property(func):
    attribute = '_lazy_' + func.__name__

    @property
    @functools.wraps(func)
    def wrapper(self):
        if not hasattr(self, attribute):
            setattr(self, attribute, func(self))
        return getattr(self, attribute)

    return wrapper


def parse_log(log_msg):
    """
    parse a logcat message
    the log should be in threadtime format
    @param log_msg:
    @return:
    """
    m = LOGCAT_THREADTIME_RE.match(log_msg)
    if not m:
        return None
    log_dict = {}
    date = m.group('date')
    time = m.group('time')
    log_dict['pid'] = m.group('pid')
    log_dict['tid'] = m.group('tid')
    log_dict['level'] = m.group('level')
    log_dict['tag'] = m.group('tag')
    log_dict['content'] = m.group('content')
    datetime_str = "%s-%s %s" % (datetime.today().year, date, time)
    log_dict['datetime'] = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S.%f")

    return log_dict


def get_available_devices():
    """
    Get a list of device serials connected via adb
    :return: list of str, each str is a device serial number
    """
    import subprocess
    r = subprocess.check_output(["adb", "devices"])
    if not isinstance(r, str):
        r = r.decode()
    devices = []
    for line in r.splitlines():
        segs = line.strip().split()
        if len(segs) == 2 and segs[1] == "device":
            devices.append(segs[0])
    return devices


def weighted_choice(choices):
    import random
    total = sum(choices[c] for c in list(choices.keys()))
    r = random.uniform(0, total)
    upto = 0
    for c in list(choices.keys()):
        if upto + choices[c] > r:
            return c
        upto += choices[c]


def safe_re_match(regex, content):
    if not regex or not content:
        return None
    else:
        return regex.match(content)


def md5(input_str):
    import hashlib
    return hashlib.md5(input_str.encode('utf-8')).hexdigest()


def init_breakpoint(app_dir):
    # set up breakpoint for testing multiple apps
    breakpoint_path = os.path.join(app_dir, 'breakpoint.txt')
    if not os.path.exists(breakpoint_path):
        with open(breakpoint_path, "a+", encoding='utf-8') as f:
            pass
    with open(breakpoint_path, "r+", encoding='utf-8') as f:
        apk_done = f.read()
    return breakpoint_path, apk_done


def diff(a, b):
    return list(set(b).difference(set(a)))


def clear_folders(device_serial):
    """
    clear folders loaded by testing apps on device for batch testing in sdcard
    """
    standard = ['Alarms', 'Android', 'DCIM', 'Download', 'Movies', 'Music', 'Notifications', 'Pictures', 'Podcasts',
                'Ringtones', 'DriveByDownload', 'storage']
    pip = os.popen("adb -s " + device_serial + " shell cd /sdcard;ls")
    output = pip.buffer.read().decode(encoding='utf8')
    # TODO: 'r\r\n' need to adjust according to platform
    dir_list = output.split('\r\r\n')
    diffs = diff(standard, dir_list)
    for _dir in diffs:
        if _dir:
            _dir = _dir.replace(' ', '\\ ')
            os.system("adb -s " + device_serial + " shell rm -rf /sdcard/" + _dir)

    if 'DriveByDownload' not in dir_list:
        os.system('adb -s ' + device_serial + " shell mkdir /DriveByDownload")


def init_device(device_serial, if_clear_folders=True):

    if is_device_locked(device_serial):
        unlock_device(device_serial)
        import time
        time.sleep(1)

    # open wifi connection
    os.system('adb -s ' + device_serial + " shell svc wifi enable")
    # close location
    os.system('adb -s ' + device_serial + " shell settings put secure location_providers_allowed -gps")
    os.system('adb -s ' + device_serial + " shell settings put secure location_providers_allowed -network")

    if if_clear_folders:
        clear_folders(device_serial)


def is_device_locked(device_serial):
    cmd_check_lockscreen = 'adb -s ' + device_serial + ' shell dumpsys window policy'
    if 'mShowingLockscreen=true' in os.popen(cmd_check_lockscreen).read():
        return True
    else:
        return False


def is_device_on(device_serial):
    cmd_check_lockscreen = 'adb -s ' + device_serial + ' shell dumpsys window policy'
    if 'mScreenOnFully=true' in os.popen(cmd_check_lockscreen).read():
        return True
    else:
        return False


def unlock_device(device_serial):
    prefix = 'adb -s ' + device_serial + ' shell '
    cmds = [
        'input swipe 500 1500 500 500',
        'input text 1111',
        'input tap 1010 1546',
    ]
    if not is_device_on(device_serial):
        cmds.insert(0, 'input keyevent 26')
    for cmd in cmds:
        time.sleep(0.1)
        os.system(prefix + cmd)


